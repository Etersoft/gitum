#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# git-um - Git Upstream Manager.
# Copyright (C) 2011  Pavel Shilovsky <piastry@etersoft.ru>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from gitupstream import *
import sys
import argparse

def main():
	parser = argparse.ArgumentParser(description='Git Upstream Manager')
	parser.add_argument('--repo', help='path to the gitum repo (does not take affect in clone command)')
	subparsers = parser.add_subparsers(dest='command_name')

	merge_p = subparsers.add_parser('merge')
	gr = merge_p.add_mutually_exclusive_group()
	gr.add_argument('--continue', action='store_true', help='continue a merge process')
	gr.add_argument('--skip', action='store_true', help='skip the current patch in rebase and continue a merge process')
	gr.add_argument('--abort', action='store_true', help='abort a merge process')
	gr.add_argument('--branch', help='local/remote branch to merge from')

	update_p = subparsers.add_parser('update')
	gr_update = update_p.add_mutually_exclusive_group()
	gr_update.add_argument('-n', '--number', metavar='N', help='number of commits to process')
	gr_update.add_argument('--range', metavar='since:to', help='commit range to process')

	create_p = subparsers.add_parser('create')
	create_p.add_argument('--remote', metavar='server/branch', help='remote branch to track with')
	create_p.add_argument('--current', metavar='branch', help='current development branch')
	create_p.add_argument('--upstream', metavar='branch', help='copy of tracked upstream branch')
	create_p.add_argument('--rebased', metavar='branch', help='branch with our patches on top')
	create_p.add_argument('--patches', metavar='branch', help='branch consists of our patches as files')

	remove_p = subparsers.add_parser('remove')
	remove_p.add_argument('--full', action='store_true', help='remove branches and config files (default)')
	remove_p.add_argument('--branches', action='store_true', help='remove branches')
	remove_p.add_argument('--configfiles', action='store_true', help='remove config files')

	editpatch_p = subparsers.add_parser('editpatch')
	gr_editpatch = editpatch_p.add_mutually_exclusive_group()
	gr_editpatch.add_argument('--continue', action='store_true', help='continue a editpatch process')
	gr_editpatch.add_argument('--skip', action='store_true', help='skip the current patch in rebase and continue a editpatch process')
	gr_editpatch.add_argument('--abort', action='store_true', help='abort a editpatch process')
	gr_editpatch.add_argument('--commit', action='store_true', help='commit changes into current development branch')

	restore_p = subparsers.add_parser('restore')
	restore_p.add_argument('commit', help='commit to restore from')

	clone_p = subparsers.add_parser('clone')
	clone_p.add_argument('git-repo', help='git repo to clone from')
	clone_p.add_argument('repo-dir', help='directory to clone to')

	pull_p = subparsers.add_parser('pull')
	pull_p.add_argument('--remote', help='remote repo to pull from')
	gr_pull = pull_p.add_mutually_exclusive_group()
	gr_pull.add_argument('--resolved', action='store_true', help='continue a pull process')
	gr_pull.add_argument('--skip', action='store_true', help='skip the current patch and continue a pull process')
	gr_pull.add_argument('--abort', action='store_true', help='abort a pull process')

	push_p = subparsers.add_parser('push')
	push_p.add_argument('--remote', help='remote repo to push to')

	args = vars(parser.parse_args(sys.argv[1:]))

	if args['repo']:
		path = args['repo']
	else:
		path = '.'

	if not args['command_name'] == 'clone':
		repo = GitUpstream(path, with_log=True)

	if args['command_name'] == 'merge':
		try:
			if args['continue']:
				repo.continue_merge('--continue')
			elif args['skip']:
				repo.continue_merge('--skip')
			elif args['abort']:
				repo.abort()
			elif args['branch']:
				repo.merge(args['branch'])
			else:
				repo.merge()
		except GitUmException:
			pass
	elif args['command_name'] == 'update':
		try:
			if args['number']:
				repo.update(int(args['number']))
			elif args['range']:
				repo.update_range(args['range'])
		except GitUmException:
			pass
	elif args['command_name'] == 'editpatch':
		try:
			if args['continue']:
				repo.edit_patch('--continue')
			elif args['skip']:
				repo.edit_patch('--skip')
			elif args['abort']:
				repo.edit_patch('--abort')
			elif args['commit']:
				repo.edit_patch('--commit')
			else:
				repo.edit_patch()
		except GitUmException:
			pass
	elif args['command_name'] == 'create':
		# default branch names
		upstream_branch = 'upstream'
		rebased_branch = 'rebased'
		current_branch = 'current'
		remote_branch = 'origin/master'
		patches_branch = 'patches'
		if args['remote']:
			remote_branch = args['remote']
		if args['current']:
			current_branch = args['current']
		if args['upstream']:
			upstream_branch = args['upstream']
		if args['rebased']:
			rebased_branch = args['rebased']
		if args['patches']:
			rebased_branch = args['patches']
		try:
			repo.create(remote_branch, current_branch, upstream_branch, rebased_branch, patches_branch)
		except GitUmException:
			pass
	elif args['command_name'] == 'restore':
		try:
			repo.restore(args['commit'])
		except GitUmException:
			pass
	elif args['command_name'] == 'remove':
		try:
			if args['branches']:
				repo.remove_branches()
			elif args['configfiles']:
				repo.remove_config_files()
			else:
				repo.remove_all()
		except GitUmException:
			pass
	elif args['command_name'] == 'clone':
		GitUpstream(repo_path=args['repo-dir'], with_log=True, new_repo=True).clone(args['git-repo'])
	elif args['command_name'] == 'pull':
		try:
			if args['resolved']:
				repo.continue_pull('--resolved')
			elif args['skip']:
				repo.continue_pull('--skip')
			elif args['abort']:
				repo.abort(am=True)
			else:
				if args['remote']:
					repo.pull(args['remote'])
				else:
					repo.pull()
		except GitUmException:
			pass
	elif args['command_name'] == 'push':
		if args['remote']:
			repo.push(args['remote'])
		else:
			repo.push()

if __name__ == "__main__":
	main()
